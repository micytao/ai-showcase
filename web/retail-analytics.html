<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Smart Retail Analytics - Heat Map Demo</title>
    <link rel="icon" type="image/png" href="../assets/ai-showcase.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #dc2626;
            --primary-hover: #b91c1c;
            --secondary-color: #f3f4f6;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --border-color: #e5e7eb;
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, #e0f2fe 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 1.5rem;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            gap: 1.5rem;
            grid-template-columns: 1fr 400px;
        }

        .header {
            grid-column: 1 / -1;
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .mode-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            border: 2px solid var(--border-color);
        }

        .mode-indicator.active {
            background: #dcfce7;
            border-color: var(--success-color);
            color: var(--success-color);
            font-weight: 600;
        }

        .main-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 0.75rem;
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .heatmap-container {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 0.75rem;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-top: 1rem;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        #heatmapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
        }

        .legend-gradient {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, 
                rgba(0, 0, 255, 0.3) 0%,
                rgba(0, 255, 255, 0.4) 25%,
                rgba(0, 255, 0, 0.5) 50%,
                rgba(255, 255, 0, 0.6) 75%,
                rgba(255, 0, 0, 0.7) 100%);
            border-radius: 0.25rem;
        }

        .legend-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.25rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: var(--text-primary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e5e7eb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .stats-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-md);
        }

        .stats-panel h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-card {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
            border-left: 4px solid var(--primary-color);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .stat-unit {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stat-trend {
            font-size: 0.75rem;
            color: var(--success-color);
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .zone-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .zone-card {
            background: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 2px solid var(--border-color);
            text-align: center;
        }

        .zone-card.hot {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .zone-card.warm {
            border-color: #f59e0b;
            background: #fffbeb;
        }

        .zone-card.cool {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .zone-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .zone-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .activity-log {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .activity-item {
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .activity-time {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .config-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-md);
        }

        .config-panel h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 0.625rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: border-color 0.2s;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <i class="fas fa-fire"></i>
                Smart Retail Analytics - Heat Map
            </h1>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="mode-indicator" id="modeIndicator">
                    <i class="fas fa-circle" style="font-size: 0.5rem;"></i>
                    <span id="modeText">Ready</span>
                </div>
            </div>
        </div>

        <div class="main-panel">
            <div class="video-container">
                <video id="videoElement" autoplay playsinline></video>
                <canvas id="overlayCanvas"></canvas>
            </div>

            <!-- Progress Bar -->
            <div id="progressContainer" style="display: none; margin-top: 1rem; background: var(--bg-secondary); border-radius: 0.5rem; padding: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">
                        <i class="fas fa-chart-line"></i> Analysis & Heatmap Progress
                    </div>
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                        <span id="progressText">0%</span>
                    </div>
                </div>
                <div style="width: 100%; height: 8px; background: var(--border-color); border-radius: 1rem; overflow: hidden;">
                    <div id="progressBar" style="height: 100%; background: linear-gradient(90deg, var(--primary-color), #f59e0b); width: 0%; transition: width 0.3s ease; border-radius: 1rem;"></div>
                </div>
                <div id="progressDetails" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary); display: flex; justify-content: space-between;">
                    <span><i class="fas fa-video"></i> Video: <span id="videoProgress">0:00 / 0:00</span></span>
                    <span><i class="fas fa-brain"></i> Analyzed: <span id="framesAnalyzed">0</span> frames</span>
                </div>
            </div>

            <div class="controls">
                <button id="startBtn" class="btn btn-primary">
                    <i class="fas fa-video"></i>
                    Start Camera
                </button>
                <button id="loadRetailVideoBtn" class="btn btn-primary">
                    <i class="fas fa-shopping-cart"></i>
                    Load Retail Demo Video
                </button>
                <label for="videoUpload" class="btn btn-primary" style="cursor: pointer; margin: 0;">
                    <i class="fas fa-upload"></i>
                    Upload Video
                    <input type="file" id="videoUpload" accept="video/*" style="display: none;">
                </label>
                <button id="playVideoBtn" class="btn btn-secondary" disabled>
                    <i class="fas fa-play"></i>
                    Play
                </button>
                <button id="stopBtn" class="btn btn-secondary" disabled>
                    <i class="fas fa-stop"></i>
                    Stop
                </button>
                <button id="resetHeatmapBtn" class="btn btn-secondary">
                    <i class="fas fa-redo"></i>
                    Reset Heatmap
                </button>
                <button id="toggleOverlayBtn" class="btn btn-secondary">
                    <i class="fas fa-eye"></i>
                    Toggle Overlay
                </button>
                <button id="toggleHeatmapBtn" class="btn btn-secondary">
                    <i class="fas fa-fire"></i>
                    Toggle Heatmap
                </button>
            </div>
            
            <div style="background: var(--bg-secondary); padding: 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">
                <strong>üí° Demo Tip:</strong> Click "Load Retail Demo Video" to analyze the embedded retail footage, upload your own video, or use your camera. The AI will analyze customer movement and generate a traffic heatmap in real time.
            </div>
            
            <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(124, 58, 237, 0.05)); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 0.5rem; padding: 0.75rem; font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.75rem;">
                <strong style="color: #8b5cf6;">ü§ñ AI Disclaimer:</strong> The retail demo video is fully AI-generated content created for demonstration purposes. It does not depict real individuals or actual retail locations.
            </div>
            
            <div style="background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05)); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 0.5rem; padding: 0.75rem; font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.75rem;">
                <strong style="color: #f59e0b;">‚ö° Detection Info:</strong> Detection boxes show VLM snapshots every 2 seconds (not real-time tracking). 
                <strong style="color: #10b981;">‚óè</strong> <strong>LIVE</strong> = fresh detection, 
                <strong style="color: #6b7280;">‚óã</strong> <strong>X s ago</strong> = older snapshot. 
                Movement paths connect detections over time.
            </div>

            <div style="background: var(--bg-secondary); border-radius: 0.5rem; padding: 1rem; margin-top: 0.75rem; border: 2px solid var(--border-color);">
                <div class="form-checkbox" style="margin-bottom: 0;">
                    <input type="checkbox" id="enablePromptEdit">
                    <label class="form-label" style="margin: 0; font-weight: 600;">
                        <i class="fas fa-edit"></i>
                        Enable Prompt Editing
                    </label>
                </div>

                <div id="promptEditWrapper" style="display: none; margin-top: 1rem;">
                    <label class="form-label" style="font-weight: 600;">
                        <i class="fas fa-comment-dots"></i>
                        VLM Prompt
                    </label>
                    <textarea id="vlmPrompt" class="form-input" rows="8" style="resize: vertical;">Analyze this retail store image and detect all visible people.

Your response must be ONLY a single-line JSON object with this EXACT structure:
{"count": N, "people": [{"x": P1, "y": P2}, {"x": P3, "y": P4}]}

CRITICAL REQUIREMENTS:
‚Ä¢ NO markdown, NO code blocks, NO ``` symbols
‚Ä¢ NO explanations or extra text - JSON only
‚Ä¢ "x" and "y" are PERCENTAGES from 0 to 100 (NOT pixels)
‚Ä¢ x: 0=left edge, 50=center, 100=right edge
‚Ä¢ y: 0=top edge, 50=middle, 100=bottom edge
‚Ä¢ EVERY person object MUST have BOTH "x" AND "y" keys
‚Ä¢ count must equal the number of objects in people array
‚Ä¢ Use double quotes (") not single quotes (')

EXAMPLES OF CORRECT OUTPUT:
{"count": 1, "people": [{"x": 50, "y": 50}]}
{"count": 3, "people": [{"x": 25, "y": 40}, {"x": 60, "y": 55}, {"x": 85, "y": 30}]}

BAD - DO NOT DO THIS:
```json {...}``` ‚ùå (no markdown)
{"count": 2, "people": [{"x": 800, "y": 600}]} ‚ùå (pixels not percentages)
{"x": 50, 60} ‚ùå (missing "y:" label)

Return your JSON response now:</textarea>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem;">
                        <i class="fas fa-info-circle"></i> Modify the prompt to change how the VLM analyzes images
                    </div>
                </div>
            </div>

            <div class="heatmap-container">
                <canvas id="heatmapCanvas"></canvas>
            </div>

            <div class="heatmap-legend">
                <span class="legend-label">Low Traffic</span>
                <div class="legend-gradient"></div>
                <span class="legend-label">High Traffic</span>
            </div>
        </div>

        <div class="sidebar">
            <div class="stats-panel">
                <h2>
                    <i class="fas fa-chart-line"></i>
                    Real-Time Metrics
                </h2>

                <div class="stat-card">
                    <div class="stat-label">Current Visitors</div>
                    <div class="stat-value">
                        <span id="currentVisitors">0</span>
                        <span class="stat-unit">people</span>
                    </div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Total Visitors Today</div>
                    <div class="stat-value">
                        <span id="totalVisitors">0</span>
                    </div>
                    <div class="stat-trend">
                        <i class="fas fa-arrow-up"></i>
                        <span>+12% vs yesterday</span>
                    </div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Avg. Dwell Time</div>
                    <div class="stat-value">
                        <span id="avgDwellTime">0</span>
                        <span class="stat-unit">seconds</span>
                    </div>
                </div>

                <h2 style="margin-top: 1.5rem;">
                    <i class="fas fa-map-marked-alt"></i>
                    Zone Analysis
                </h2>

                <div class="zone-stats">
                    <div class="zone-card hot">
                        <div class="zone-name">Hot Zone</div>
                        <div class="zone-value" style="color: #ef4444;">
                            <i class="fas fa-fire"></i>
                            <span id="hotZone">0</span>%
                        </div>
                    </div>
                    <div class="zone-card warm">
                        <div class="zone-name">Warm Zone</div>
                        <div class="zone-value" style="color: #f59e0b;">
                            <i class="fas fa-temperature-high"></i>
                            <span id="warmZone">0</span>%
                        </div>
                    </div>
                    <div class="zone-card cool">
                        <div class="zone-name">Cool Zone</div>
                        <div class="zone-value" style="color: #3b82f6;">
                            <i class="fas fa-snowflake"></i>
                            <span id="coolZone">0</span>%
                        </div>
                    </div>
                    <div class="zone-card">
                        <div class="zone-name">Cold Zone</div>
                        <div class="zone-value" style="color: #6b7280;">
                            <i class="fas fa-cloud"></i>
                            <span id="coldZone">0</span>%
                        </div>
                    </div>
                </div>
            </div>

            <div class="config-panel">
                <h3>
                    <i class="fas fa-cog"></i>
                    Configuration
                </h3>

                <div class="form-group" style="margin-bottom: 1.5rem;">
                    <button id="testConnectionBtn" class="btn btn-primary" style="width: 100%; font-size: 1rem; padding: 1rem;">
                        <i class="fas fa-wifi"></i>
                        Test VLM Connection
                    </button>
                </div>

                <div class="form-group">
                    <label class="form-label">
                        <i class="fas fa-server"></i>
                        RHAIIS vLLM Endpoint
                    </label>
                    <select id="vllmEndpointSelect" class="form-input" onchange="handleVllmEndpointChange()">
                        <option value="https://rhaiis-route-rhaiis.apps.cluster-pjc5d.pjc5d.sandbox1225.opentlc.com">Embedded Model (Default)</option>
                        <option value="maas">MaaS (Configured Models)</option>
                        <option value="custom">Custom Endpoint...</option>
                    </select>
                    <div id="customVllmEndpointWrapper" style="display: none; margin-top: 0.75rem;">
                        <input type="text" id="baseURL" class="form-input" placeholder="Enter custom endpoint URL (e.g., https://api.openai.com)" style="margin-bottom: 0.5rem;">
                        <input type="password" id="apiKey" class="form-input" placeholder="API Key (optional - required for some endpoints)" style="margin-bottom: 0.5rem;">
                        <button id="fetchModelsBtn" class="btn btn-secondary" onclick="fetchAvailableModels()" style="width: 100%; margin-bottom: 0.5rem;">
                            <i class="fas fa-download"></i>
                            Fetch Available Models
                        </button>
                        <select id="modelSelect" class="form-input" disabled>
                            <option value="">Select a model (fetch models first)</option>
                        </select>
                    </div>
                    <div id="maasVllmEndpointWrapper" style="display: none; margin-top: 0.75rem;">
                        <select id="maasModelSelect" class="form-input" onchange="handleMaasModelSelection()" style="margin-bottom: 0.5rem;">
                            <option value="">-- Select a configured model --</option>
                        </select>
                        <div id="maasModelInfo" style="display: none; padding: 0.75rem; background: var(--bg-secondary); border-radius: 0.5rem; border: 1px solid var(--border-color); font-size: 0.8125rem;">
                            <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 0.5rem;">
                                <i class="fas fa-info-circle"></i> Selected Model Details
                            </div>
                            <div style="color: var(--text-secondary);">
                                <strong>Name:</strong> <span id="maasModelName">-</span><br>
                                <strong>Endpoint:</strong> <span id="maasModelEndpoint">-</span><br>
                                <strong>Model:</strong> <span id="maasModelId">-</span><br>
                                <strong>Status:</strong> <span id="maasModelStatus" style="color: var(--success-color);">‚úì Tested Successfully</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(239, 68, 68, 0.05)); border: 1px solid rgba(220, 38, 38, 0.2); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.75rem; color: var(--text-secondary);">
                    <strong style="color: var(--primary-color);">üè¢ Enterprise Setup:</strong> Using Red Hat AI Inference Server (RHAIIS) with vLLM backend.<br>
                    <strong>Default:</strong> Uses embedded model (rhaiis-route-rhaiis.apps.cluster-pjc5d.pjc5d.sandbox1225.opentlc.com)<br>
                    <strong>Model:</strong> Qwen2-VL-2B-Instruct (Vision Language Model)<br>
                    <strong>API:</strong> OpenAI-compatible (Port 8000)
                </div>

                <div class="form-group">
                    <label class="form-label">
                        <i class="fas fa-robot"></i>
                        VLM Response
                    </label>
                    <div id="vlmResponse" style="min-height: 100px; max-height: 200px; overflow-y: auto; padding: 0.75rem; border: 2px solid var(--border-color); border-radius: 0.5rem; background: var(--bg-secondary); font-size: 0.8125rem; color: var(--text-primary); line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; text-align: left !important; display: block;">
                        <div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--text-secondary); font-style: italic;">VLM analysis results will appear here...</span></div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Analysis Interval (seconds)</label>
                    <input type="number" id="analysisInterval" class="form-input" value="2" min="1" max="10">
                </div>

                <div class="form-group">
                    <label class="form-label">Heatmap Radius</label>
                    <input type="range" id="heatRadius" class="form-input" value="50" min="20" max="100">
                    <span style="font-size: 0.75rem; color: var(--text-secondary);">
                        <span id="radiusValue">50</span>px
                    </span>
                </div>

                <div class="form-checkbox">
                    <input type="checkbox" id="showDetections" checked>
                    <label class="form-label" style="margin: 0;">Show Detection Boxes</label>
                </div>

                <div class="form-checkbox">
                    <input type="checkbox" id="showPaths" checked>
                    <label class="form-label" style="margin: 0;">Show Movement Paths</label>
                </div>
            </div>

            <div class="stats-panel">
                <h2>
                    <i class="fas fa-history"></i>
                    Activity Log
                </h2>
                <div class="activity-log" id="activityLog">
                    <div class="activity-item">
                        <i class="fas fa-info-circle" style="color: var(--primary-color);"></i>
                        <span>System ready. Start camera to begin tracking.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        let isRunning = false;
        let stream = null;
        let analysisInterval = null;
        let heatmapData = [];
        let visitorCount = 0;
        let totalVisitorCount = 0;
        let dwellTimes = [];
        let detectedPeople = [];
        let movementPaths = {}; // Track paths per person ID {personId: [{x, y, timestamp}]}
        let personFirstSeen = {}; // Track when each person was first detected {personId: timestamp}
        let showOverlay = true;
        let isUsingUploadedVideo = false;
        let uploadedVideoFile = null;
        let framesAnalyzedCount = 0;
        let progressUpdateInterval = null;
        let currentObjectUrl = null; // Track object URLs for cleanup
        const MAX_PATH_LENGTH = 30; // Keep last 30 positions per person
        
        // Helper function to escape HTML to prevent XSS
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // DOM elements
        const videoElement = document.getElementById('videoElement');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const heatmapCtx = heatmapCanvas.getContext('2d');
        
        // Validate canvas contexts
        if (!overlayCtx || !heatmapCtx) {
            console.error('‚ùå Failed to get canvas 2D contexts');
            alert('Canvas rendering not supported in this browser');
        }
        
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetHeatmapBtn = document.getElementById('resetHeatmapBtn');
        const toggleOverlayBtn = document.getElementById('toggleOverlayBtn');
        const toggleHeatmapBtn = document.getElementById('toggleHeatmapBtn');
        const videoUploadInput = document.getElementById('videoUpload');
        const playVideoBtn = document.getElementById('playVideoBtn');
        const loadRetailVideoBtn = document.getElementById('loadRetailVideoBtn');
        
        const modeIndicator = document.getElementById('modeIndicator');
        const modeText = document.getElementById('modeText');
        const testConnectionBtn = document.getElementById('testConnectionBtn');
        
        let showHeatmap = true;
        
        const baseURL = document.getElementById('baseURL');
        const analysisIntervalInput = document.getElementById('analysisInterval');
        const heatRadiusInput = document.getElementById('heatRadius');
        const showDetectionsCheck = document.getElementById('showDetections');
        const showPathsCheck = document.getElementById('showPaths');
        const enablePromptEditCheck = document.getElementById('enablePromptEdit');
        const promptEditWrapper = document.getElementById('promptEditWrapper');
        const vlmPromptTextarea = document.getElementById('vlmPrompt');

        // Handle prompt editing checkbox
        enablePromptEditCheck.addEventListener('change', function() {
            if (this.checked) {
                promptEditWrapper.style.display = 'block';
            } else {
                promptEditWrapper.style.display = 'none';
            }
        });

        // Initialize endpoint with default
        function getDefaultAPIEndpoint() {
            return "https://rhaiis-route-rhaiis.apps.cluster-pjc5d.pjc5d.sandbox1225.opentlc.com";
        }
        
        baseURL.value = getDefaultAPIEndpoint();

        // Initialize canvas sizes
        function initCanvases() {
            const videoRect = videoElement.getBoundingClientRect();
            const heatmapContainer = heatmapCanvas.parentElement;
            const heatmapRect = heatmapContainer.getBoundingClientRect();
            
            // Get device pixel ratio for high-DPI displays
            const dpr = window.devicePixelRatio || 1;
            
            // Set overlay canvas to match video element (with DPI scaling)
            overlayCanvas.width = Math.round(videoRect.width * dpr);
            overlayCanvas.height = Math.round(videoRect.height * dpr);
            overlayCanvas.style.width = videoRect.width + 'px';
            overlayCanvas.style.height = videoRect.height + 'px';
            
            // Scale context for high-DPI
            overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Set heatmap canvas to match its container (which should match video aspect ratio)
            heatmapCanvas.width = Math.round(heatmapRect.width * dpr);
            heatmapCanvas.height = Math.round(heatmapRect.height * dpr);
            heatmapCanvas.style.width = heatmapRect.width + 'px';
            heatmapCanvas.style.height = heatmapRect.height + 'px';
            
            // Scale context for high-DPI
            heatmapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            console.log('üìê Canvas initialized:');
            console.log('  - Device pixel ratio:', dpr);
            console.log('  - Video element:', videoRect.width, 'x', videoRect.height);
            console.log('  - Overlay canvas:', overlayCanvas.width, 'x', overlayCanvas.height, '(physical)');
            console.log('  - Overlay canvas:', videoRect.width, 'x', videoRect.height, '(CSS)');
            console.log('  - Heatmap container:', heatmapRect.width, 'x', heatmapRect.height);
            console.log('  - Heatmap canvas:', heatmapCanvas.width, 'x', heatmapCanvas.height, '(physical)');
            console.log('  - Heatmap canvas:', heatmapRect.width, 'x', heatmapRect.height, '(CSS)');
            console.log('  - Canvas visible:', heatmapCanvas.style.display !== 'none');
            
            // Initialize heatmap data grid (use CSS size for grid, not physical pixels)
            const gridWidth = Math.ceil(heatmapRect.width / 10);
            const gridHeight = Math.ceil(heatmapRect.height / 10);
            heatmapData = Array(gridHeight).fill(0).map(() => Array(gridWidth).fill(0));
            
            console.log('  - Grid size:', gridWidth, 'x', gridHeight);
            console.log('  - Aspect ratio check: video=', (videoRect.width / videoRect.height).toFixed(2), 
                        ', heatmap=', (heatmapRect.width / heatmapRect.height).toFixed(2));
            
            // Test: Draw a red rectangle on heatmap canvas to verify it's working
            console.log('üß™ Drawing test rectangle on heatmap canvas...');
            heatmapCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            heatmapCtx.fillRect(50, 50, 100, 100);
            console.log('  - Test rectangle drawn at (50, 50) 100x100');
        }

        // Start camera
        async function startCamera() {
            try {
                // Stop any uploaded video first
                if (isUsingUploadedVideo) {
                    videoElement.pause();
                    videoElement.src = '';
                    isUsingUploadedVideo = false;
                    uploadedVideoFile = null;
                    playVideoBtn.disabled = true;
                }
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                // Set isRunning FIRST before everything else
                isRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    console.log('üìπ Camera video loaded, initializing...');
                    // Track start time for camera mode
                    videoElement._startTime = Date.now();
                    initCanvases();
                    startAnalysis();
                    // Show progress bar for camera mode
                    showProgressBar();
                };
                
                updateModeIndicator('camera');
                addActivityLog('Camera started', 'success');
            } catch (error) {
                console.error('Error accessing camera:', error);
                addActivityLog('Failed to access camera', 'error');
                alert('Could not access camera. Please ensure camera permissions are granted.');
            }
        }

        // Stop camera or video
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            }
            
            // Hide progress bar
            hideProgressBar();
            
            // Revoke object URL to prevent memory leak
            if (currentObjectUrl) {
                URL.revokeObjectURL(currentObjectUrl);
                currentObjectUrl = null;
            }
            
            // Pause video if it's playing
            if (isUsingUploadedVideo) {
                videoElement.pause();
                playVideoBtn.disabled = false;
                playVideoBtn.innerHTML = '<i class="fas fa-play"></i> Play';
            }
            
            // Reset VLM response box
            const vlmResponseBox = document.getElementById('vlmResponse');
            if (vlmResponseBox) {
                vlmResponseBox.innerHTML = '<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--text-secondary); font-style: italic;">VLM analysis results will appear here...</span></div>';
            }
            
            isRunning = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            updateModeIndicator(isUsingUploadedVideo ? 'paused' : 'ready');
            addActivityLog(isUsingUploadedVideo ? 'Video stopped' : 'Camera stopped', 'info');
        }

        // Handle video upload
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Stop any existing camera/video
            if (isRunning) {
                stopCamera();
            }
            
            // Revoke previous object URL if it exists
            if (currentObjectUrl) {
                URL.revokeObjectURL(currentObjectUrl);
                currentObjectUrl = null;
            }
            
            uploadedVideoFile = file;
            isUsingUploadedVideo = true;
            
            // Create object URL for the video
            const videoURL = URL.createObjectURL(file);
            currentObjectUrl = videoURL; // Track for cleanup
            videoElement.srcObject = null;
            videoElement.src = videoURL;
            
            videoElement.onloadedmetadata = () => {
                initCanvases();
                playVideoBtn.disabled = false;
                addActivityLog(`Video uploaded: ${file.name}`, 'success');
            };
            
            // Reset video upload input
            event.target.value = '';
        }

        // Load embedded retail video
        function loadRetailVideo() {
            console.log('üìπ Loading embedded retail video...');
            
            // Stop any existing camera/video
            if (isRunning) {
                stopCamera();
            }
            
            // Clear demo heatmap and reset counts
            clearDemoHeatmap();
            
            // Reset visitor counts and detections
            visitorCount = 0;
            totalVisitorCount = 0;
            detectedPeople = [];
            movementPaths = {};
            personFirstSeen = {};
            dwellTimes = [];
            updateStats();
            
            uploadedVideoFile = 'retail.mp4';
            isUsingUploadedVideo = true;
            
            // Set video source to embedded video
            videoElement.srcObject = null;
            videoElement.src = '/assets/retail.mp4';
            
            videoElement.onloadedmetadata = () => {
                console.log('‚úÖ Retail video loaded successfully');
                initCanvases();
                playVideoBtn.disabled = false;
                addActivityLog('Retail demo video loaded', 'success');
                
                // Ensure overlay and movement paths are visible
                if (!showOverlay) {
                    showOverlay = true;
                    toggleOverlayBtn.innerHTML = '<i class="fas fa-eye"></i> Hide Overlay';
                }
                
                // Ensure detection boxes and movement paths are checked
                if (!showDetectionsCheck.checked) {
                    showDetectionsCheck.checked = true;
                }
                if (!showPathsCheck.checked) {
                    showPathsCheck.checked = true;
                }
                
                // Auto-play the video
                playUploadedVideo();
            };
            
            videoElement.onerror = (e) => {
                console.error('‚ùå Error loading retail video:', e);
                addActivityLog('Failed to load retail video - check file path', 'error');
            };
        }

        // Play uploaded video
        function playUploadedVideo() {
            if (!uploadedVideoFile) return;
            
            console.log('‚ñ∂Ô∏è Playing uploaded video...');
            
            // Reset video to beginning
            videoElement.currentTime = 0;
            
            isRunning = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            playVideoBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
            
            videoElement.play();
            
            // Show progress bar
            showProgressBar();
            
            // Always start analysis when playing
            console.log('üìπ Starting analysis for uploaded video...');
            if (!analysisInterval) {
                startAnalysis();
            } else {
                console.log('‚ö†Ô∏è Analysis already running, just starting render loop...');
                // Render loop might have stopped, restart it
                if (renderLoopCount === 0 || !isRunning) {
                    renderLoop();
                }
            }
            
            // Handle video end
            videoElement.onended = () => {
                addActivityLog('Video playback completed', 'info');
                // Stop playback (this will trigger render loop to stop and do final render)
                stopCamera();
                addActivityLog('Video analysis complete - final heatmap preserved', 'success');
                hideProgressBar();
            };
            
            updateModeIndicator('video');
            addActivityLog('Video playback started', 'success');
        }
        
        // Toggle play/pause for uploaded video
        function togglePlayPause() {
            if (!isUsingUploadedVideo) return;
            
            if (videoElement.paused) {
                playUploadedVideo();
            } else {
                // Pause video but keep analysis running (for in-flight requests)
                videoElement.pause();
                playVideoBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                updateModeIndicator('paused');
                addActivityLog('Video paused', 'info');
            }
        }

        // Update mode indicator
        function updateModeIndicator(mode) {
            switch(mode) {
                case 'camera':
                    modeIndicator.classList.add('active');
                    modeText.innerHTML = '<i class="fas fa-video"></i> Live Camera';
                    break;
                case 'video':
                    modeIndicator.classList.add('active');
                    modeText.innerHTML = '<i class="fas fa-film"></i> Video Analysis';
                    break;
                case 'paused':
                    modeIndicator.classList.remove('active');
                    modeText.innerHTML = '<i class="fas fa-pause"></i> Paused';
                    break;
                case 'ready':
                default:
                    modeIndicator.classList.remove('active');
                    modeText.innerHTML = '<i class="fas fa-circle"></i> Ready';
                    break;
            }
        }

        // Start analysis loop
        function startAnalysis() {
            const interval = parseInt(analysisIntervalInput.value) * 1000;
            
            // Clear demo heatmap if present
            clearDemoHeatmap();
            
            console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
            console.log('‚ïë  üöÄ STARTING ANALYSIS         ‚ïë');
            console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
            console.log('Analysis interval:', interval, 'ms');
            console.log('isRunning:', isRunning);
            console.log('Heatmap canvas dimensions:', heatmapCanvas.width, 'x', heatmapCanvas.height);
            console.log('Heatmap data grid:', heatmapData.length, 'x', heatmapData[0]?.length);
            
            // Clear VLM response box
            const vlmResponseBox = document.getElementById('vlmResponse');
            if (vlmResponseBox) {
                vlmResponseBox.innerHTML = '<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--text-secondary); font-style: italic;"><i class="fas fa-spinner fa-spin"></i> Analyzing...</span></div>';
            }
            
            analysisInterval = setInterval(() => {
                analyzeFrame();
            }, interval);
            
            // Start continuous heatmap rendering if not already running
            if (!renderLoopRunning) {
                console.log('üìû Starting render loop...');
                console.log('   isRunning before renderLoop:', isRunning);
                renderLoop();
                console.log('‚úÖ renderLoop() started');
            } else {
                console.log('‚ÑπÔ∏è  Render loop already running, skipping start');
            }
        }

        // Handle vLLM endpoint dropdown change
        function handleVllmEndpointChange() {
            const select = document.getElementById('vllmEndpointSelect');
            const customWrapper = document.getElementById('customVllmEndpointWrapper');
            const maasWrapper = document.getElementById('maasVllmEndpointWrapper');
            const baseURLInput = document.getElementById('baseURL');
            
            // Hide both wrappers first
            customWrapper.style.display = 'none';
            maasWrapper.style.display = 'none';
            
            if (select.value === 'custom') {
                customWrapper.style.display = 'block';
                baseURLInput.focus();
            } else if (select.value === 'maas') {
                maasWrapper.style.display = 'block';
                loadMaasModels();
            } else {
                baseURLInput.value = select.value;
            }
        }

        // MaaS Model Management
        let selectedMaasConfig = null;

        // Load available MaaS models from settings
        function loadMaasModels() {
            const maasSelect = document.getElementById('maasModelSelect');
            const maasInfo = document.getElementById('maasModelInfo');
            
            // Clear existing options except the first one
            maasSelect.innerHTML = '<option value="">-- Select a configured model --</option>';
            maasInfo.style.display = 'none';
            selectedMaasConfig = null;
            
            // Load models from localStorage (from settings.html)
            const models = [];
            
            // Load VLM endpoint
            const vlmEndpoint = localStorage.getItem('vlmEndpoint');
            const vlmApiKey = localStorage.getItem('vlmApiKey');
            const vlmModel = localStorage.getItem('vlmModel');
            
            if (vlmEndpoint && vlmApiKey) {
                models.push({
                    id: 'vlm_primary',
                    name: 'VLM Primary',
                    endpoint: vlmEndpoint,
                    apiKey: vlmApiKey,
                    model: vlmModel || 'Qwen/Qwen2-VL-2B-Instruct',
                    type: 'vlm'
                });
            }
            
            // Load custom endpoints
            try {
                const customEndpoints = JSON.parse(localStorage.getItem('customEndpoints') || '[]');
                customEndpoints.forEach(endpoint => {
                    const endpointUrl = localStorage.getItem(`${endpoint.id}Endpoint`) || endpoint.endpoint;
                    const apiKey = localStorage.getItem(`${endpoint.id}ApiKey`) || endpoint.apiKey;
                    const model = localStorage.getItem(`${endpoint.id}Model`) || '';
                    
                    if (endpointUrl && apiKey) {
                        models.push({
                            id: endpoint.id,
                            name: endpoint.name,
                            endpoint: endpointUrl,
                            apiKey: apiKey,
                            model: model,
                            type: 'custom'
                        });
                    }
                });
            } catch (error) {
                console.error('Error loading custom endpoints:', error);
            }
            
            // Populate dropdown
            if (models.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No configured models found - Configure in Settings';
                option.disabled = true;
                maasSelect.appendChild(option);
                
                addActivityLog('No MaaS models configured', 'error');
            } else {
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = `${model.name} (${model.model || 'Default Model'})`;
                    option.dataset.config = JSON.stringify(model);
                    maasSelect.appendChild(option);
                });
                
                addActivityLog(`Found ${models.length} configured model(s)`, 'success');
            }
            
            console.log('üìã Loaded MaaS models:', models);
        }

        // Handle MaaS model selection
        function handleMaasModelSelection() {
            const maasSelect = document.getElementById('maasModelSelect');
            const maasInfo = document.getElementById('maasModelInfo');
            const selectedOption = maasSelect.options[maasSelect.selectedIndex];
            
            if (!selectedOption || !selectedOption.value) {
                maasInfo.style.display = 'none';
                selectedMaasConfig = null;
                return;
            }
            
            // Parse the configuration
            try {
                selectedMaasConfig = JSON.parse(selectedOption.dataset.config);
                
                // Update info display
                document.getElementById('maasModelName').textContent = selectedMaasConfig.name;
                document.getElementById('maasModelEndpoint').textContent = selectedMaasConfig.endpoint;
                document.getElementById('maasModelId').textContent = selectedMaasConfig.model || 'Default Model';
                maasInfo.style.display = 'block';
                
                // Apply the configuration
                baseURL.value = selectedMaasConfig.endpoint;
                
                addActivityLog(`Using ${selectedMaasConfig.name}`, 'success');
                
                console.log('‚úÖ Selected MaaS config:', selectedMaasConfig);
            } catch (error) {
                console.error('Error parsing MaaS config:', error);
                addActivityLog('Failed to load model config', 'error');
                selectedMaasConfig = null;
            }
        }

        // Fetch available models from the custom endpoint
        async function fetchAvailableModels() {
            const baseURLInput = document.getElementById('baseURL');
            const modelSelect = document.getElementById('modelSelect');
            const fetchBtn = document.getElementById('fetchModelsBtn');
            
            const endpoint = baseURLInput.value.trim();
            
            if (!endpoint) {
                alert('Please enter a custom endpoint URL first');
                baseURLInput.focus();
                return;
            }
            
            // Show loading state
            fetchBtn.disabled = true;
            fetchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Fetching models...';
            modelSelect.disabled = true;
            modelSelect.innerHTML = '<option value="">Loading models...</option>';
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const modelsUrl = `${endpoint}/v1/models`;
                const headers = getApiHeaders();
                
                console.log('Fetching models from:', modelsUrl);
                
                const response = await fetch(modelsUrl, {
                    method: 'GET',
                    headers: headers,
                    mode: 'cors',
                    signal: controller.signal,
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Models response:', data);
                    
                    const models = data.data || data.models || [];
                    
                    if (models.length === 0) {
                        modelSelect.innerHTML = '<option value="">No models found</option>';
                        alert('No models found at this endpoint');
                    } else {
                        modelSelect.innerHTML = '<option value="">Select a model</option>';
                        models.forEach(model => {
                            const option = document.createElement('option');
                            const modelId = model.id || model.name || model;
                            option.value = modelId;
                            option.textContent = modelId;
                            modelSelect.appendChild(option);
                        });
                        modelSelect.disabled = false;
                        
                        addActivityLog(`Found ${models.length} models`, 'success');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Error fetching models:', response.status, errorText);
                    modelSelect.innerHTML = '<option value="">Error fetching models</option>';
                    alert(`Failed to fetch models: ${response.status} ${response.statusText}\n\n${errorText}`);
                }
            } catch (error) {
                console.error('Error fetching models:', error);
                modelSelect.innerHTML = '<option value="">Error - fetch models again</option>';
                
                if (error.name === 'AbortError') {
                    alert('Request timed out after 10 seconds. Please check your endpoint URL.');
                } else if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                    alert('CORS or connection error. Make sure the endpoint allows cross-origin requests.\n\nError: ' + error.message);
                } else {
                    alert('Error fetching models: ' + error.message);
                }
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerHTML = '<i class="fas fa-download"></i> Fetch Available Models';
            }
        }

        // Get the selected model name
        function getSelectedModel() {
            const select = document.getElementById('vllmEndpointSelect');
            
            // If using MaaS and a model is selected, use it
            if (select.value === 'maas' && selectedMaasConfig && selectedMaasConfig.model) {
                console.log('üìã Using MaaS model:', selectedMaasConfig.model);
                return selectedMaasConfig.model;
            }
            
            const modelSelect = document.getElementById('modelSelect');
            
            // If using custom endpoint and a model is selected, use it
            if (select.value === 'custom' && modelSelect.value) {
                return modelSelect.value;
            }
            
            // Otherwise use the default model
            return "Qwen/Qwen2-VL-2B-Instruct";
        }

        // Get API headers
        function getApiHeaders() {
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            };
            
            const vllmSelect = document.getElementById('vllmEndpointSelect');
            
            // Use MaaS API key if MaaS is selected
            if (vllmSelect.value === 'maas' && selectedMaasConfig && selectedMaasConfig.apiKey) {
                headers['Authorization'] = `Bearer ${selectedMaasConfig.apiKey}`;
                console.log('üîë Using MaaS API key for:', selectedMaasConfig.name);
            } else {
                // Add API key if provided (for custom endpoints)
                const apiKeyInput = document.getElementById('apiKey');
                if (apiKeyInput && apiKeyInput.value.trim()) {
                    headers['Authorization'] = `Bearer ${apiKeyInput.value.trim()}`;
                }
            }
            
            return headers;
        }

        // Test VLM connection
        async function testConnection() {
            const endpoint = baseURL.value.trim();
            const vlmResponseBox = document.getElementById('vlmResponse');
            
            testConnectionBtn.disabled = true;
            testConnectionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            
            // Show testing status in VLM response box
            if (vlmResponseBox) {
                vlmResponseBox.innerHTML = '<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--text-secondary); font-style: italic;"><i class="fas fa-spinner fa-spin"></i> Testing VLM connection...</span></div>';
            }
            
            try {
                addActivityLog('Testing VLM connection...', 'info');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
                
                console.log('Testing VLM connection to:', endpoint);
                
                // Create a simple test image (100x100 black square)
                const testCanvas = document.createElement('canvas');
                testCanvas.width = 100;
                testCanvas.height = 100;
                const ctx = testCanvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 100, 100);
                const testImage = testCanvas.toDataURL('image/jpeg', 0.5);
                
                // Get the selected model
                const selectedModel = getSelectedModel();
                console.log('Using model:', selectedModel);
                
                const testPayload = {
                    model: selectedModel,
                    max_tokens: 20,
                    messages: [{
                        role: "user",
                        content: [
                            {
                                type: "text",
                                text: "Hello, can you respond?"
                            },
                            {
                                type: "image_url",
                                image_url: {
                                    url: testImage
                                }
                            }
                        ]
                    }]
                };
                
                // Build API URL
                const apiUrl = `${endpoint}/v1/chat/completions`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    mode: 'cors',
                    signal: controller.signal,
                    body: JSON.stringify(testPayload)
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    const testResponse = data.choices?.[0]?.message?.content || 'API responded correctly';
                    
                    addActivityLog(`‚úÖ VLM connection successful!`, 'success');
                    
                    // Display success in VLM response box (sanitized)
                    if (vlmResponseBox) {
                        vlmResponseBox.innerHTML = `<div style="color: var(--success-color); text-align: left !important; display: block; width: 100%;">
                            <div style="text-align: left !important;"><strong><i class="fas fa-check-circle"></i> Connection Test Passed!</strong></div><br>
                            <div style="text-align: left !important;"><strong>Endpoint:</strong> ${escapeHtml(endpoint)}</div>
                            <div style="text-align: left !important;"><strong>Model:</strong> ${escapeHtml(selectedModel)}</div>
                            <div style="text-align: left !important;"><strong>Test Response:</strong> ${escapeHtml(testResponse)}</div><br>
                            <div style="text-align: left !important;"><em style="color: var(--text-secondary);">You can now start the demo.</em></div>
                        </div>`;
                    }
                } else {
                    const errorText = await response.text();
                    
                    addActivityLog(`‚ö†Ô∏è VLM server reachable but API error: ${response.status}`, 'warning');
                    
                    // Display error in VLM response box (sanitized)
                    if (vlmResponseBox) {
                        vlmResponseBox.innerHTML = `<div style="color: var(--danger-color); text-align: left !important; display: block; width: 100%;">
                            <div style="text-align: left !important;"><strong><i class="fas fa-exclamation-triangle"></i> API Error</strong></div><br>
                            <div style="text-align: left !important;"><strong>Endpoint:</strong> ${escapeHtml(endpoint)}</div>
                            <div style="text-align: left !important;"><strong>Status:</strong> ${response.status} ${escapeHtml(response.statusText)}</div>
                            <div style="text-align: left !important;"><strong>Error:</strong> ${escapeHtml(errorText)}</div><br>
                            <div style="text-align: left !important;"><em style="color: var(--text-secondary);">The server is reachable but returned an error. Check server logs for details.</em></div>
                        </div>`;
                    }
                }
                
            } catch (error) {
                console.error('Connection test failed:', error);
                
                const serverInfo = endpoint;
                let errorMsg = '';
                let troubleshooting = '';
                
                if (error.name === 'AbortError') {
                    errorMsg = 'Connection test timed out after 15 seconds.';
                    troubleshooting = '‚Ä¢ Check if VLM server is running<br>‚Ä¢ Verify the URL is correct<br>‚Ä¢ Check for network issues<br><br><strong>Endpoint:</strong> ' + serverInfo;
                } else if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                    errorMsg = 'Cannot reach VLM server - CORS or connection error.';
                    troubleshooting = '‚Ä¢ Check if RHAIIS vLLM server is running<br>‚Ä¢ Verify server URL is correct<br>‚Ä¢ Use External Route (recommended)<br>‚Ä¢ Check CORS configuration if using custom URL<br><br><strong>Endpoint:</strong> ' + serverInfo + '<br><strong>Error:</strong> ' + error.message;
                } else {
                    errorMsg = 'Connection error: ' + error.message;
                    troubleshooting = '‚Ä¢ Check browser console for details<br>‚Ä¢ Verify VLM server configuration<br>‚Ä¢ Check network connectivity<br><br><strong>Endpoint:</strong> ' + serverInfo;
                }
                
                addActivityLog('‚ùå ' + errorMsg, 'error');
                
                // Display error in VLM response box (sanitized)
                if (vlmResponseBox) {
                    vlmResponseBox.innerHTML = `<div style="color: var(--danger-color); text-align: left !important; display: block; width: 100%;">
                        <div style="text-align: left !important;"><strong><i class="fas fa-times-circle"></i> Connection Test Failed</strong></div><br>
                        <div style="text-align: left !important;">${escapeHtml(errorMsg)}</div><br>
                        <div style="text-align: left !important;"><strong>Troubleshooting:</strong></div>
                        <div style="text-align: left !important;">${troubleshooting}</div>
                    </div>`;
                }
            } finally {
                testConnectionBtn.disabled = false;
                testConnectionBtn.innerHTML = '<i class="fas fa-wifi"></i> Test VLM Connection';
            }
        }

        // Analyze frame using VLM
        async function analyzeFrame() {
            if (!isRunning) return;
            
            // Check if video has valid dimensions
            if (!videoElement.videoWidth || !videoElement.videoHeight) {
                console.warn('‚ö†Ô∏è Video dimensions not ready, skipping frame analysis');
                return;
            }
            
            try {
                // Capture frame from video
                const canvas = document.createElement('canvas');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                const ctx = canvas.getContext('2d');
                
                if (!ctx) {
                    console.error('‚ùå Failed to get temporary canvas context');
                    return;
                }
                
                ctx.drawImage(videoElement, 0, 0);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.95);
                
                // Get endpoint and model
                const endpoint = baseURL.value.trim();
                const selectedModel = getSelectedModel();
                const apiUrl = `${endpoint}/v1/chat/completions`;
                
                // Create timeout controller (longer timeout for VLM inference)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 120 second timeout (2 minutes)
                
                // Get the prompt (from textarea if editing is enabled, otherwise use default)
                const promptText = vlmPromptTextarea.value;
                
                // Call VLM API
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    mode: 'cors',
                    signal: controller.signal,
                    body: JSON.stringify({
                        model: selectedModel,
                        messages: [{
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: promptText
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: imageData
                                    }
                                }
                            ]
                        }],
                        max_tokens: 8192,
                        temperature: 0.01
                    })
                });
                
                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const content = data.choices[0].message.content;
                
                console.log('üì• Raw VLM response:', content);
                
                // Increment frames analyzed counter
                framesAnalyzedCount++;
                
                // Parse VLM response
                parseAndUpdateDetections(content);
                
            } catch (error) {
                console.error('Analysis error:', error);
                
                // Display error in VLM response box
                const vlmResponseBox = document.getElementById('vlmResponse');
                let errorMsg = 'Analysis error: ';
                let shouldStopAnalysis = false;
                
                if (error.name === 'AbortError') {
                    errorMsg += 'Request timed out after 2 minutes. VLM inference is taking too long.';
                    if (vlmResponseBox) {
                        vlmResponseBox.innerHTML = `<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--danger-color);"><i class="fas fa-clock"></i> Request timed out. Try increasing the Analysis Interval or check VLM server performance.</span></div>`;
                    }
                } else if (error.message.includes('Failed to fetch')) {
                    errorMsg += 'Cannot reach VLM server. Click "Test VLM Connection" to diagnose.';
                    shouldStopAnalysis = true;
                    if (vlmResponseBox) {
                        vlmResponseBox.innerHTML = `<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--danger-color);"><i class="fas fa-exclamation-triangle"></i> Cannot reach VLM server. Click "Test VLM Connection" to diagnose.</span></div>`;
                    }
                } else {
                    errorMsg += error.message;
                    if (vlmResponseBox) {
                        vlmResponseBox.innerHTML = `<div style="text-align: left !important; display: block; width: 100%;"><span style="color: var(--danger-color);"><i class="fas fa-exclamation-triangle"></i> ${escapeHtml(error.message)}</span></div>`;
                    }
                }
                
                addActivityLog(errorMsg, 'error');
                
                // Pause analysis on connection failure only
                if (shouldStopAnalysis && isRunning) {
                    stopCamera();
                    addActivityLog('‚ö†Ô∏è Analysis paused due to connection error', 'error');
                }
            }
        }

        // Parse VLM response and update detections
        function parseAndUpdateDetections(content) {
            // Process VLM responses even if analysis has stopped (in-flight requests)
            console.log('üìä Processing VLM response (isRunning=' + isRunning + ')');
            
            // Display VLM response in the response box (will be updated after parsing)
            const vlmResponseBox = document.getElementById('vlmResponse');
            
            try {
                // Try multiple strategies to extract and parse JSON
                let data = null;
                
                // Strategy 1: Try to find JSON between ```json and ``` markers
                const codeBlockMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                if (codeBlockMatch) {
                    console.log('Found JSON in code block');
                    let jsonStr = codeBlockMatch[1];
                    
                    // Apply cleaning to code block JSON too
                    jsonStr = jsonStr
                        .replace(/,\s*([\]}])/g, '$1')  // Remove trailing commas
                        .replace(/:\s*'([^']*)'/g, ': "$1"')  // Replace single quotes with double quotes in values
                        .replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3')  // Fix unquoted keys
                        .replace(/("x"\s*:\s*\d+\.?\d*),\s*(\d+\.?\d*)\s*\}/g, '$1, "y": $2}');  // Fix missing "y" key
                    
                    try {
                        data = JSON.parse(jsonStr);
                        console.log('‚úÖ Successfully parsed code block JSON');
                    } catch (e) {
                        console.warn('Code block JSON parse failed, falling back to strategy 2:', e);
                        // Fall through to strategy 2
                    }
                }
                
                if (!data) {
                    // Strategy 2: Find the first { and last } to extract JSON
                    const firstBrace = content.indexOf('{');
                    const lastBrace = content.lastIndexOf('}');
                    
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                        let jsonStr = content.substring(firstBrace, lastBrace + 1);
                        console.log('Extracted JSON string (length:', jsonStr.length, ')');
                        
                        // Check if JSON appears truncated (missing closing braces)
                        const openBraces = (jsonStr.match(/\{/g) || []).length;
                        const closeBraces = (jsonStr.match(/\}/g) || []).length;
                        const openBrackets = (jsonStr.match(/\[/g) || []).length;
                        const closeBrackets = (jsonStr.match(/\]/g) || []).length;
                        
                        console.log('Brace balance: { =', openBraces, ', } =', closeBraces, '| [ =', openBrackets, ', ] =', closeBrackets);
                        
                        if (openBraces > closeBraces || openBrackets > closeBrackets) {
                            console.warn('‚ö†Ô∏è JSON appears truncated, attempting to fix...');
                            
                            // Truncated response - try to close it properly
                            // Remove incomplete last entry
                            const lastCommaIndex = jsonStr.lastIndexOf(',');
                            if (lastCommaIndex > jsonStr.lastIndexOf('}')) {
                                jsonStr = jsonStr.substring(0, lastCommaIndex);
                            }
                            
                            // Add missing closing brackets/braces
                            while (openBrackets > closeBrackets) {
                                jsonStr += ']';
                                closeBrackets++;
                            }
                            while (openBraces > closeBraces) {
                                jsonStr += '}';
                                closeBraces++;
                            }
                            
                            console.log('Fixed JSON (length:', jsonStr.length, ')');
                            addActivityLog('‚ö†Ô∏è VLM response was truncated, using partial data', 'warning');
                        }
                        
                        // Clean up common JSON issues
                        let cleanedJson = jsonStr
                            .replace(/,\s*([\]}])/g, '$1')  // Remove trailing commas
                            .replace(/:\s*'([^']*)'/g, ': "$1"')  // Replace single quotes with double quotes in values
                            .replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3')  // Fix unquoted keys (only if not already quoted)
                            .replace(/("x"\s*:\s*\d+\.?\d*),\s*(\d+\.?\d*)\s*\}/g, '$1, "y": $2}');  // Fix missing "y" key: {"x": 310, 40} -> {"x": 310, "y": 40}
                        
                        console.log('Cleaned JSON:', cleanedJson.substring(0, 200) + '...');
                        
                        // Special case: Fix malformed JSON with multiple "people" keys
                        // Pattern: {"count": 9, "people": [...], "people": [...], "people": [...]}
                        if (cleanedJson.includes('"people"') && (cleanedJson.match(/"people"/g) || []).length > 1) {
                            console.warn('‚ö†Ô∏è Detected multiple "people" keys, attempting to merge...');
                            
                            // Extract all coordinate objects from the entire string
                            const allCoordinates = [];
                            const coordRegex = /\{\s*"x"\s*:\s*(\d+\.?\d*)\s*,\s*"y"\s*:\s*(\d+\.?\d*)\s*\}/g;
                            let match;
                            while ((match = coordRegex.exec(cleanedJson)) !== null) {
                                allCoordinates.push({
                                    x: parseFloat(match[1]),
                                    y: parseFloat(match[2])
                                });
                            }
                            
                            // Extract count
                            const countMatch = cleanedJson.match(/"count"\s*:\s*(\d+)/);
                            const count = countMatch ? parseInt(countMatch[1]) : allCoordinates.length;
                            
                            // Rebuild proper JSON
                            cleanedJson = JSON.stringify({
                                count: count,
                                people: allCoordinates
                            });
                            
                            console.log('‚úÖ Merged multiple "people" keys into one array:', allCoordinates.length, 'people');
                        }
                        
                        try {
                            data = JSON.parse(cleanedJson);
                        } catch (parseError) {
                            // If parsing still fails, try more aggressive cleaning
                            console.warn('First parse attempt failed, trying more aggressive cleaning...');
                            console.log('Original jsonStr:', jsonStr);
                            
                            // More aggressive cleaning for MaaS models
                            let ultraCleanedJson = jsonStr
                                // Remove any markdown or extra text
                                .replace(/```json\s*/g, '')
                                .replace(/```\s*/g, '')
                                // Normalize whitespace
                                .replace(/\s+/g, ' ')
                                // Fix single quotes to double quotes (but not inside strings)
                                .replace(/'/g, '"')
                                // Remove trailing commas
                                .replace(/,\s*([\]}])/g, '$1')
                                // Fix unquoted property names (match word characters followed by colon)
                                .replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3')
                                // Ensure property names are double-quoted if they somehow got single-quoted
                                .replace(/([{,]\s*)'([a-zA-Z0-9_]+)'(\s*:)/g, '$1"$2"$3')
                                // Remove any non-JSON characters at the start and end
                                .trim();
                            
                            console.log('Ultra-cleaned JSON:', ultraCleanedJson);
                            
                            try {
                                data = JSON.parse(ultraCleanedJson);
                            } catch (parseError2) {
                                console.warn('Second parse attempt failed, trying manual extraction...');
                                
                                // Try to extract just the core data we need
                                const countMatch = jsonStr.match(/"?count"?\s*:\s*(\d+)/i);
                                const peopleMatch = jsonStr.match(/"?people"?\s*:\s*(\[[\s\S]*?\](?:\s*\})?)$/i);
                                
                                if (countMatch || peopleMatch) {
                                    // Build a valid JSON from extracted parts
                                    const count = countMatch ? parseInt(countMatch[1]) : 0;
                                    let people = [];
                                    
                                    if (peopleMatch) {
                                        try {
                                            // Extract just the array part, removing any trailing }
                                            let peopleArrayStr = peopleMatch[1].replace(/\s*\}\s*$/, '');
                                            
                                            // Apply the same aggressive cleaning to the people array
                                            peopleArrayStr = peopleArrayStr
                                                .replace(/'/g, '"')
                                                .replace(/,\s*([\]}])/g, '$1')
                                                .replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3');
                                            
                                            console.log('Cleaned people array:', peopleArrayStr);
                                            people = JSON.parse(peopleArrayStr);
                                        } catch (e) {
                                            console.warn('Could not parse people array, trying manual extraction:', e);
                                            
                                            // Last resort: extract individual x, y coordinates
                                            // Match various formats: {x: 50, y: 30}, {'x': 50, 'y': 30}, {x:50,y:30}, etc.
                                            const coordinateMatches = jsonStr.matchAll(/\{\s*['"']?([xX])['"']?\s*:\s*(\d+\.?\d*)\s*,\s*['"']?([yY])['"']?\s*:\s*(\d+\.?\d*)\s*\}/g);
                                            for (const match of coordinateMatches) {
                                                people.push({
                                                    x: parseFloat(match[2]),
                                                    y: parseFloat(match[4])
                                                });
                                            }
                                            console.log('Manually extracted people:', people);
                                        }
                                    }
                                    
                                    data = { count: count, people: people };
                                    console.log('‚úÖ Extracted data from malformed JSON:', data);
                                } else {
                                    throw parseError2; // Re-throw if we can't extract anything useful
                                }
                            }
                        }
                    }
                }
                
                if (data) {
                    const peopleCount = data.count || data.people_count || data.peopleCount || 0;
                    const people = data.people || data.persons || [];
                    
                    console.log('‚úÖ Parsed VLM data:', { peopleCount, actualPeople: people.length });
                    
                    // Display formatted VLM response in the response box
                    if (vlmResponseBox) {
                        let formattedHTML = `<div style="text-align: left !important; display: block; width: 100%;">`;
                        formattedHTML += `<div style="color: var(--success-color); font-weight: 600; margin-bottom: 8px;">`;
                        formattedHTML += `<i class="fas fa-check-circle"></i> VLM Analysis Complete</div>`;
                        formattedHTML += `<div style="margin-bottom: 8px;">`;
                        formattedHTML += `<strong>People Detected:</strong> ${people.length}</div>`;
                        
                        if (people.length > 0) {
                            formattedHTML += `<div style="margin-top: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 4px; font-size: 0.85em;">`;
                            formattedHTML += `<strong>Positions:</strong><br>`;
                            people.forEach((person, idx) => {
                                const personX = escapeHtml(String(person.x));
                                const personY = escapeHtml(String(person.y));
                                formattedHTML += `‚Ä¢ Person ${idx + 1}: (${personX}%, ${personY}%)<br>`;
                            });
                            formattedHTML += `</div>`;
                        }
                        
                        // Show raw response in collapsed section (sanitized)
                        formattedHTML += `<details style="margin-top: 8px; font-size: 0.8em;">`;
                        formattedHTML += `<summary style="cursor: pointer; color: var(--text-secondary);">View Raw Response</summary>`;
                        formattedHTML += `<pre style="margin-top: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(content)}</pre>`;
                        formattedHTML += `</details>`;
                        formattedHTML += `</div>`;
                        
                        vlmResponseBox.innerHTML = formattedHTML;
                    }
                    
                    // Update visitor count
                    visitorCount = people.length; // Use actual parsed people count
                    // Track peak occupancy (maximum people seen at once)
                    totalVisitorCount = Math.max(totalVisitorCount, people.length);
                    
                    // Track previous people for dwell time calculation
                    const previousPeopleIds = new Set(detectedPeople.map(p => p.id));
                    
                    // Update detections - clamp coordinates to valid range (0-100%)
                    // IMPORTANT: VLM returns positions as percentages of the video frame (0-100%)
                    // We map these to heatmap canvas pixel coordinates
                    const newDetectedPeople = people.map((person, idx) => {
                        // Extract percentage values (handle both "50%" and "50" formats)
                        let xStr = String(person.x || person.X || '50');
                        let yStr = String(person.y || person.Y || '50');
                        
                        // Remove % sign if present
                        xStr = xStr.replace('%', '');
                        yStr = yStr.replace('%', '');
                        
                        // Parse values
                        let xValue = parseFloat(xStr) || 50;
                        let yValue = parseFloat(yStr) || 50;
                        
                        // Auto-detect if values are in 0-1 range (normalized) or 0-100 range (percentage)
                        // If value is between 0-1, treat as normalized (0-1), otherwise as percentage (0-100)
                        let xPercent, yPercent;
                        
                        if (xValue <= 1.0 && xValue >= 0) {
                            // Value is in 0-1 range, convert to percentage
                            xPercent = xValue * 100;
                            console.log(`  X: ${xValue} detected as normalized (0-1), converting to ${xPercent}%`);
                        } else {
                            // Value is already a percentage, clamp to valid range
                            xPercent = Math.max(0, Math.min(100, xValue));
                        }
                        
                        if (yValue <= 1.0 && yValue >= 0) {
                            // Value is in 0-1 range, convert to percentage
                            yPercent = yValue * 100;
                            console.log(`  Y: ${yValue} detected as normalized (0-1), converting to ${yPercent}%`);
                        } else {
                            // Value is already a percentage, clamp to valid range
                            yPercent = Math.max(0, Math.min(100, yValue));
                        }
                        
                        // Convert percentage positions to heatmap canvas pixel coordinates
                        // Since both video and heatmap have same aspect ratio (16:9), percentages map directly
                        const x = xPercent / 100 * heatmapCanvas.width;
                        const y = yPercent / 100 * heatmapCanvas.height;
                        
                        // Generate person ID based on position (within ~10% grid to allow for slight movement)
                        const gridX = Math.floor(xPercent / 10);
                        const gridY = Math.floor(yPercent / 10);
                        const personId = `person_${gridX}_${gridY}`;
                        
                        console.log(`Person ${idx + 1}: raw(${xValue}, ${yValue}) -> percent(${xPercent.toFixed(1)}%, ${yPercent.toFixed(1)}%) -> canvas(${x.toFixed(0)}px, ${y.toFixed(0)}px) -> ID: ${personId}`);
                        
                        // Track when person was first seen (for dwell time)
                        if (!personFirstSeen[personId]) {
                            personFirstSeen[personId] = Date.now();
                            console.log(`  üÜï New person detected: ${personId}`);
                        }
                        
                        // Track movement path for this person
                        if (!movementPaths[personId]) {
                            movementPaths[personId] = [];
                        }
                        movementPaths[personId].push({
                            x: x,
                            y: y,
                            timestamp: Date.now()
                        });
                        
                        // Keep only recent positions
                        if (movementPaths[personId].length > MAX_PATH_LENGTH) {
                            movementPaths[personId].shift();
                        }
                        
                        return { 
                            id: personId,
                            x, 
                            y, 
                            activity: person.activity || 'browsing',
                            timestamp: Date.now() // Track when this detection was made
                        };
                    });
                    
                    // Calculate dwell time for people who left
                    const newPeopleIds = new Set(newDetectedPeople.map(p => p.id));
                    previousPeopleIds.forEach(oldId => {
                        if (!newPeopleIds.has(oldId) && personFirstSeen[oldId]) {
                            const dwellTime = (Date.now() - personFirstSeen[oldId]) / 1000; // Convert to seconds
                            dwellTimes.push(dwellTime);
                            console.log(`  üëã Person left: ${oldId}, dwell time: ${dwellTime.toFixed(1)}s`);
                            
                            // Keep only last 100 dwell times
                            if (dwellTimes.length > 100) {
                                dwellTimes.shift();
                            }
                            
                            // Clean up tracking data
                            delete personFirstSeen[oldId];
                        }
                    });
                    
                    detectedPeople = newDetectedPeople;
                    
                    console.log('Detected people positions:', detectedPeople.length);
                    
                    // Add to heatmap
                    console.log('Adding', detectedPeople.length, 'people to heatmap...');
                    detectedPeople.forEach((person, idx) => {
                        addHeatmapPoint(person.x, person.y);
                    });
                    
                    // Immediately render the heatmap to show the new data
                    renderHeatmap();
                    
                    // If the render loop is not running, we still want to show this data
                    // Even if analysis has stopped, render once to show in-flight data
                    if (!renderLoopRunning) {
                        console.log('üîÑ Analysis stopped but rendering in-flight VLM data...');
                        // Just render once, don't restart the full loop
                        renderHeatmap();
                    } else if (!isRunning && analysisInterval === null) {
                        // Analysis fully stopped but render loop is running - keep it going briefly
                        console.log('üîÑ Keeping render loop active for in-flight data...');
                    }
                    
                    // Update stats
                    updateStats();
                    
                    if (people.length > 0) {
                        addActivityLog(`Detected ${people.length} ${people.length === 1 ? 'person' : 'people'}`, 'success');
                    }
                } else {
                    console.warn('No valid JSON found in VLM response');
                    addActivityLog('Could not extract JSON from VLM response', 'warning');
                    
                    // Display raw response even if parsing failed (sanitized)
                    if (vlmResponseBox) {
                        let formattedHTML = `<div style="text-align: left !important; display: block; width: 100%;">`;
                        formattedHTML += `<div style="color: var(--danger-color); font-weight: 600; margin-bottom: 8px;">`;
                        formattedHTML += `<i class="fas fa-exclamation-triangle"></i> Could not parse JSON</div>`;
                        formattedHTML += `<div style="margin-bottom: 8px; color: var(--text-secondary); font-size: 0.85em;">`;
                        formattedHTML += `The VLM response doesn't contain valid JSON. Raw response below:</div>`;
                        formattedHTML += `<pre style="padding: 8px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; font-size: 0.8em;">${escapeHtml(content)}</pre>`;
                        formattedHTML += `</div>`;
                        vlmResponseBox.innerHTML = formattedHTML;
                    }
                }
            } catch (error) {
                console.error('Parse error:', error);
                console.error('Failed to parse content:', content);
                addActivityLog('Failed to parse VLM response: ' + error.message, 'warning');
                
                // Display error and raw response (sanitized)
                if (vlmResponseBox) {
                    let formattedHTML = `<div style="text-align: left !important; display: block; width: 100%;">`;
                    formattedHTML += `<div style="color: var(--danger-color); font-weight: 600; margin-bottom: 8px;">`;
                    formattedHTML += `<i class="fas fa-exclamation-triangle"></i> Parse Error</div>`;
                    formattedHTML += `<div style="margin-bottom: 8px; color: var(--text-secondary); font-size: 0.85em;">`;
                    formattedHTML += `Error: ${escapeHtml(error.message)}</div>`;
                    formattedHTML += `<details style="margin-top: 8px; font-size: 0.8em;">`;
                    formattedHTML += `<summary style="cursor: pointer; color: var(--text-secondary);">View Raw Response</summary>`;
                    formattedHTML += `<pre style="margin-top: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(content)}</pre>`;
                    formattedHTML += `</details>`;
                    formattedHTML += `</div>`;
                    vlmResponseBox.innerHTML = formattedHTML;
                }
                
                // Fallback: simple pattern matching
                const countMatch = content.match(/(\d+)\s+(?:people|person)/i);
                if (countMatch) {
                    visitorCount = parseInt(countMatch[1]);
                    updateStats();
                    addActivityLog(`Detected ${visitorCount} people (fallback parsing)`, 'info');
                }
            }
        }

        // Add point to heatmap
        function addHeatmapPoint(x, y) {
            const gridX = Math.floor(x / 10);
            const gridY = Math.floor(y / 10);
            const radius = parseInt(heatRadiusInput.value) / 10;
            
            console.log(`Adding heatmap point at (${x}, ${y}) -> grid (${gridX}, ${gridY}), radius: ${radius}`);
            
            let pointsAdded = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= radius) {
                        const gx = gridX + dx;
                        const gy = gridY + dy;
                        
                        if (gy >= 0 && gy < heatmapData.length && gx >= 0 && gx < heatmapData[0].length) {
                            const intensity = 1 - (distance / radius);
                            // Increased from 50 to 150 for better visibility
                            heatmapData[gy][gx] = Math.min(255, heatmapData[gy][gx] + intensity * 150);
                            pointsAdded++;
                        }
                    }
                }
            }
            
            console.log(`Added ${pointsAdded} heatmap grid points`);
        }

        // Render loop
        let renderLoopCount = 0;
        let renderLoopRunning = false;
        function renderLoop() {
            // Only keep rendering while analysis is actively running
            const shouldRender = isRunning || analysisInterval !== null;
            
            if (!shouldRender) {
                console.log('‚ùå Render loop stopped - analysis complete');
                console.log('   Final state: isRunning=' + isRunning + ', analysisInterval=' + analysisInterval);
                renderLoopRunning = false;
                renderLoopCount = 0;
                
                // Render one final time to preserve the final heatmap
                renderHeatmap();
                console.log('‚úÖ Final heatmap rendered');
                return;
            }
            
            renderLoopRunning = true;
            renderLoopCount++;
            if (renderLoopCount === 1) {
                console.log('üé¨ RENDER LOOP STARTED!');
                console.log('   Conditions: isRunning=' + isRunning + ', analysisInterval=' + (analysisInterval !== null) + ', detectedPeople=' + detectedPeople.length);
            }
            if (renderLoopCount % 60 === 0) { // Log every 60 frames (~1 second)
                console.log('üîÑ Render loop running...', renderLoopCount, 'frames (detections: ' + detectedPeople.length + ')');
            }
            
            // Render heatmap FIRST
            renderHeatmap();
            
            // Clear overlay (use CSS dimensions, DPI handled by transform)
            const videoRect = videoElement.getBoundingClientRect();
            overlayCtx.clearRect(0, 0, videoRect.width, videoRect.height);
            
            // Draw movement paths FIRST (behind detection boxes)
            if (showOverlay && showPathsCheck.checked) {
                drawMovementPaths();
            }
            
            // Draw detections on overlay (on top of paths)
            if (showOverlay && showDetectionsCheck.checked) {
                drawDetections();
            }
            
            // Continue animation loop
            requestAnimationFrame(renderLoop);
        }

        // Draw movement paths
        function drawMovementPaths() {
            overlayCtx.save();
            
            // Draw paths for each person
            Object.keys(movementPaths).forEach((personId, index) => {
                const path = movementPaths[personId];
                
                if (path.length < 2) return; // Need at least 2 points to draw a path
                
                // Get color for this person
                const colors = [
                    '#3b82f6', // Blue
                    '#10b981', // Green
                    '#f59e0b', // Orange
                    '#8b5cf6', // Purple
                    '#ec4899', // Pink
                    '#06b6d4', // Cyan
                ];
                const color = colors[index % colors.length];
                
                // Scale coordinates from heatmap to overlay canvas (CSS coordinates - DPI scaling handled by context)
                const heatmapRect = heatmapCanvas.parentElement.getBoundingClientRect();
                const videoRect = videoElement.getBoundingClientRect();
                const scaleX = videoRect.width / heatmapRect.width;
                const scaleY = videoRect.height / heatmapRect.height;
                
                // Draw path line
                overlayCtx.beginPath();
                overlayCtx.strokeStyle = color;
                overlayCtx.lineWidth = 3;
                overlayCtx.lineCap = 'round';
                overlayCtx.lineJoin = 'round';
                
                // Start from first point
                const firstPoint = path[0];
                overlayCtx.moveTo(firstPoint.x * scaleX, firstPoint.y * scaleY);
                
                // Draw line through all points
                for (let i = 1; i < path.length; i++) {
                    const point = path[i];
                    overlayCtx.lineTo(point.x * scaleX, point.y * scaleY);
                }
                
                overlayCtx.stroke();
                
                // Draw dots on path with fade effect
                path.forEach((point, i) => {
                    const age = (Date.now() - point.timestamp) / 1000; // seconds
                    const opacity = Math.max(0.2, 1 - (age / 10)); // Fade over 10 seconds
                    
                    overlayCtx.fillStyle = color.replace(')', `, ${opacity})`).replace('rgb', 'rgba');
                    overlayCtx.beginPath();
                    overlayCtx.arc(point.x * scaleX, point.y * scaleY, 4, 0, Math.PI * 2);
                    overlayCtx.fill();
                });
                
                // Draw arrow at the end to show direction
                if (path.length >= 2) {
                    const lastPoint = path[path.length - 1];
                    const prevPoint = path[path.length - 2];
                    
                    const dx = lastPoint.x - prevPoint.x;
                    const dy = lastPoint.y - prevPoint.y;
                    const angle = Math.atan2(dy, dx);
                    
                    const arrowX = lastPoint.x * scaleX;
                    const arrowY = lastPoint.y * scaleY;
                    const arrowSize = 10;
                    
                    overlayCtx.fillStyle = color;
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(arrowX, arrowY);
                    overlayCtx.lineTo(
                        arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
                        arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    overlayCtx.lineTo(
                        arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
                        arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    overlayCtx.closePath();
                    overlayCtx.fill();
                }
            });
            
            overlayCtx.restore();
        }

        // Draw detection overlays
        function drawDetections() {
            overlayCtx.save();
            
            const now = Date.now();
            
            detectedPeople.forEach((person, index) => {
                // Scale coordinates from heatmap to overlay canvas (CSS coordinates - DPI scaling handled by context)
                const heatmapRect = heatmapCanvas.parentElement.getBoundingClientRect();
                const videoRect = videoElement.getBoundingClientRect();
                const scaleX = videoRect.width / heatmapRect.width;
                const scaleY = videoRect.height / heatmapRect.height;
                const overlayX = person.x * scaleX;
                const overlayY = person.y * scaleY;
                
                // Calculate age of detection
                const age = (now - person.timestamp) / 1000; // seconds
                const isFresh = age < 3; // Fresh if less than 3 seconds old
                
                // Fade out detection box if it's getting old (helps show it's not real-time tracking)
                const opacity = Math.max(0.3, 1 - (age / 10)); // Fade over 10 seconds
                
                // VLM typically gives center of mass or chest position
                // Adjust box position so the VLM point is at upper chest area
                const boxWidth = 100;
                const boxHeight = 140;
                
                // Position box so VLM point is at about 30% down from top (upper chest/shoulder area)
                const boxX = overlayX - boxWidth / 2;
                const boxY = overlayY - (boxHeight * 0.3); // VLM point at 30% from top
                
                // Draw semi-transparent fill
                overlayCtx.fillStyle = `rgba(239, 68, 68, ${0.08 * opacity})`;
                overlayCtx.fillRect(boxX, boxY, boxWidth, boxHeight);
                
                // Draw border (color changes based on freshness)
                if (isFresh) {
                    overlayCtx.strokeStyle = `rgba(239, 68, 68, ${opacity})`; // Red when fresh
                } else {
                    overlayCtx.strokeStyle = `rgba(156, 163, 175, ${opacity})`; // Gray when old
                }
                overlayCtx.lineWidth = isFresh ? 3 : 2;
                overlayCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                
                // Draw corner brackets for modern look
                const bracketSize = 15;
                overlayCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                overlayCtx.lineWidth = 3;
                overlayCtx.lineCap = 'round';
                
                // Top-left bracket
                overlayCtx.beginPath();
                overlayCtx.moveTo(boxX + bracketSize, boxY);
                overlayCtx.lineTo(boxX, boxY);
                overlayCtx.lineTo(boxX, boxY + bracketSize);
                overlayCtx.stroke();
                
                // Top-right bracket
                overlayCtx.beginPath();
                overlayCtx.moveTo(boxX + boxWidth - bracketSize, boxY);
                overlayCtx.lineTo(boxX + boxWidth, boxY);
                overlayCtx.lineTo(boxX + boxWidth, boxY + bracketSize);
                overlayCtx.stroke();
                
                // Bottom-left bracket
                overlayCtx.beginPath();
                overlayCtx.moveTo(boxX, boxY + boxHeight - bracketSize);
                overlayCtx.lineTo(boxX, boxY + boxHeight);
                overlayCtx.lineTo(boxX + bracketSize, boxY + boxHeight);
                overlayCtx.stroke();
                
                // Bottom-right bracket
                overlayCtx.beginPath();
                overlayCtx.moveTo(boxX + boxWidth, boxY + boxHeight - bracketSize);
                overlayCtx.lineTo(boxX + boxWidth, boxY + boxHeight);
                overlayCtx.lineTo(boxX + boxWidth - bracketSize, boxY + boxHeight);
                overlayCtx.stroke();
                
                // Draw VLM detection point (where the model thinks the person is)
                // This is the actual coordinate the VLM gave us
                overlayCtx.fillStyle = isFresh ? `rgba(251, 191, 36, ${opacity})` : `rgba(156, 163, 175, ${opacity})`; // Yellow/amber when fresh, gray when old
                overlayCtx.beginPath();
                overlayCtx.arc(overlayX, overlayY, 8, 0, Math.PI * 2);
                overlayCtx.fill();
                
                // White border for detection point
                overlayCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                overlayCtx.lineWidth = 2;
                overlayCtx.stroke();
                
                // Add pulsing animation for fresh detections
                if (isFresh) {
                    const pulseSize = 8 + Math.sin(Date.now() / 200) * 3;
                    overlayCtx.strokeStyle = `rgba(251, 191, 36, ${0.5 * opacity})`;
                    overlayCtx.lineWidth = 2;
                    overlayCtx.beginPath();
                    overlayCtx.arc(overlayX, overlayY, pulseSize, 0, Math.PI * 2);
                    overlayCtx.stroke();
                }
                
                // Draw center crosshair at VLM point
                overlayCtx.strokeStyle = isFresh ? `rgba(251, 191, 36, ${opacity})` : `rgba(156, 163, 175, ${opacity})`;
                overlayCtx.lineWidth = 2;
                overlayCtx.beginPath();
                overlayCtx.moveTo(overlayX - 15, overlayY);
                overlayCtx.lineTo(overlayX + 15, overlayY);
                overlayCtx.moveTo(overlayX, overlayY - 15);
                overlayCtx.lineTo(overlayX, overlayY + 15);
                overlayCtx.stroke();
                
                // Draw label at top
                const labelText = `Person ${index + 1}`;
                const statusIcon = isFresh ? '‚óè' : '‚óã'; // Solid dot for fresh, hollow for old
                
                overlayCtx.font = 'bold 14px Inter';
                const textMetrics = overlayCtx.measureText(labelText + ' ' + statusIcon);
                const labelWidth = textMetrics.width + 16;
                const labelHeight = 24;
                const labelX = overlayX - labelWidth / 2;
                const labelY = boxY - labelHeight - 5;
                
                // Draw label background with rounded corners
                if (isFresh) {
                    overlayCtx.fillStyle = `rgba(239, 68, 68, ${0.95 * opacity})`;
                } else {
                    overlayCtx.fillStyle = `rgba(107, 114, 128, ${0.8 * opacity})`;
                }
                overlayCtx.beginPath();
                overlayCtx.roundRect(labelX, labelY, labelWidth, labelHeight, 4);
                overlayCtx.fill();
                
                // Draw label text
                overlayCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                overlayCtx.textAlign = 'center';
                overlayCtx.textBaseline = 'middle';
                overlayCtx.fillText(`${labelText} ${statusIcon}`, overlayX, labelY + labelHeight / 2);
                
                // Draw age badge (shows how old the detection is)
                const ageText = isFresh ? 'LIVE' : `${age.toFixed(0)}s ago`;
                
                overlayCtx.font = '10px monospace';
                const ageMetrics = overlayCtx.measureText(ageText);
                const ageWidth = ageMetrics.width + 10;
                const ageHeight = 16;
                const ageX = overlayX - ageWidth / 2;
                const ageY = boxY + boxHeight + 5;
                
                // Background
                if (isFresh) {
                    overlayCtx.fillStyle = `rgba(16, 185, 129, ${0.9 * opacity})`; // Green for live
                } else {
                    overlayCtx.fillStyle = `rgba(107, 114, 128, ${0.8 * opacity})`; // Gray for old
                }
                overlayCtx.beginPath();
                overlayCtx.roundRect(ageX, ageY, ageWidth, ageHeight, 3);
                overlayCtx.fill();
                
                // Text
                overlayCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                overlayCtx.textAlign = 'center';
                overlayCtx.fillText(ageText, overlayX, ageY + ageHeight / 2);
                
                // Draw coordinate info badge (for debugging)
                const coordPercent = {
                    x: ((person.x / heatmapCanvas.width) * 100).toFixed(0),
                    y: ((person.y / heatmapCanvas.height) * 100).toFixed(0)
                };
                const coordText = `${coordPercent.x}%, ${coordPercent.y}%`;
                
                overlayCtx.font = '10px monospace';
                const coordMetrics = overlayCtx.measureText(coordText);
                const coordWidth = coordMetrics.width + 10;
                const coordHeight = 16;
                const coordX = overlayX - coordWidth / 2;
                const coordY = ageY + ageHeight + 3;
                
                // Background
                overlayCtx.fillStyle = `rgba(59, 130, 246, ${0.8 * opacity})`;
                overlayCtx.beginPath();
                overlayCtx.roundRect(coordX, coordY, coordWidth, coordHeight, 3);
                overlayCtx.fill();
                
                // Text
                overlayCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                overlayCtx.textAlign = 'center';
                overlayCtx.fillText(coordText, overlayX, coordY + coordHeight / 2);
                
                // Draw activity badge if available
                if (person.activity && person.activity !== 'unknown') {
                    overlayCtx.font = '11px Inter';
                    const activityMetrics = overlayCtx.measureText(person.activity);
                    const activityWidth = activityMetrics.width + 12;
                    const activityHeight = 18;
                    const activityX = overlayX - activityWidth / 2;
                    const activityY = coordY + coordHeight + 3;
                    
                    // Background
                    overlayCtx.fillStyle = `rgba(139, 92, 246, ${0.9 * opacity})`;
                    overlayCtx.beginPath();
                    overlayCtx.roundRect(activityX, activityY, activityWidth, activityHeight, 3);
                    overlayCtx.fill();
                    
                    // Text
                    overlayCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    overlayCtx.textAlign = 'center';
                    overlayCtx.fillText(person.activity, overlayX, activityY + activityHeight / 2);
                }
            });
            
            overlayCtx.restore();
        }

        // Render heatmap - CLEAR & INTUITIVE VERSION
        let renderHeatmapCount = 0;
        let hasLoggedFirstIntensity = false;
        
        // Reusable offscreen canvas for better performance
        let offscreenCanvas = null;
        let offscreenCtx = null;
        
        function renderHeatmap() {
            // Get CSS dimensions for drawing (DPI scaling handled by context transform)
            const heatmapRect = heatmapCanvas.parentElement.getBoundingClientRect();
            // Round to avoid fractional pixel comparison issues
            const cssWidth = Math.round(heatmapRect.width);
            const cssHeight = Math.round(heatmapRect.height);
            
            // Clear canvas with dark background
            heatmapCtx.fillStyle = 'rgba(20, 20, 30, 0.95)';
            heatmapCtx.fillRect(0, 0, cssWidth, cssHeight);
            
            let maxIntensity = 0;
            let nonZeroPoints = 0;
            
            // First pass: find max intensity for normalization
            for (let gridY = 0; gridY < heatmapData.length; gridY++) {
                for (let gridX = 0; gridX < heatmapData[0].length; gridX++) {
                    const intensity = heatmapData[gridY][gridX];
                    if (intensity > maxIntensity) maxIntensity = intensity;
                    if (intensity > 1) nonZeroPoints++;
                }
            }
            
            if (nonZeroPoints === 0) {
                renderHeatmapCount++;
                return; // Nothing to render
            }
            
            // Create or reuse offscreen canvas for the heatmap layer
            // Only recreate if dimensions actually changed
            if (!offscreenCanvas || offscreenCanvas.width !== cssWidth || offscreenCanvas.height !== cssHeight) {
                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = cssWidth;
                offscreenCanvas.height = cssHeight;
                offscreenCtx = offscreenCanvas.getContext('2d');
                console.log('üìê Created/resized offscreen canvas:', cssWidth, 'x', cssHeight);
            } else {
                // Clear existing offscreen canvas (reusing it - no recreation!)
                offscreenCtx.clearRect(0, 0, cssWidth, cssHeight);
            }
            
            // Draw heat blobs with radial gradients
            for (let gridY = 0; gridY < heatmapData.length; gridY++) {
                for (let gridX = 0; gridX < heatmapData[0].length; gridX++) {
                    const intensity = heatmapData[gridY][gridX];
                    
                    if (intensity > 1) {
                        // Convert grid coordinates to canvas pixels
                        const x = (gridX + 0.5) * 10;
                        const y = (gridY + 0.5) * 10;
                        
                        // Normalize intensity (0-1 range)
                        const normalizedIntensity = Math.min(intensity / Math.max(maxIntensity, 100), 1);
                        
                        // Dynamic radius based on intensity and settings
                        const baseRadius = parseInt(heatRadiusInput.value);
                        const radius = baseRadius * (0.7 + normalizedIntensity * 0.5); // Scale 0.7-1.2x
                        
                        // Create radial gradient for this point
                        const gradient = offscreenCtx.createRadialGradient(x, y, 0, x, y, radius);
                        
                        // Get color based on intensity
                        const color = getHeatmapColor(normalizedIntensity);
                        
                        // Gradient stops for smooth blend
                        gradient.addColorStop(0, color.center);
                        gradient.addColorStop(0.5, color.mid);
                        gradient.addColorStop(1, color.edge);
                        
                        // Draw the heat blob
                        offscreenCtx.fillStyle = gradient;
                        offscreenCtx.beginPath();
                        offscreenCtx.arc(x, y, radius, 0, Math.PI * 2);
                        offscreenCtx.fill();
                    }
                }
            }
            
            // Apply blur to the offscreen canvas for smooth appearance
            // Use filter on the main canvas draw operation instead of self-drawing
            heatmapCtx.save();
            heatmapCtx.filter = 'blur(20px)';
            heatmapCtx.globalAlpha = 0.85;
            heatmapCtx.drawImage(offscreenCanvas, 0, 0);
            heatmapCtx.restore();
            
            // Add subtle grid overlay for context
            heatmapCtx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            heatmapCtx.lineWidth = 1;
            for (let i = 0; i < cssWidth; i += 50) {
                heatmapCtx.beginPath();
                heatmapCtx.moveTo(i, 0);
                heatmapCtx.lineTo(i, cssHeight);
                heatmapCtx.stroke();
            }
            for (let i = 0; i < cssHeight; i += 50) {
                heatmapCtx.beginPath();
                heatmapCtx.moveTo(0, i);
                heatmapCtx.lineTo(cssWidth, i);
                heatmapCtx.stroke();
            }
            
            renderHeatmapCount++;
            
            // Logging
            if (renderHeatmapCount % 60 === 0) {
                console.log(`üé® Heatmap render #${renderHeatmapCount}: max=${maxIntensity.toFixed(2)}, points=${nonZeroPoints}`);
            }
            
            // Log first time we render with intensity
            if (maxIntensity > 0 && !hasLoggedFirstIntensity) {
                hasLoggedFirstIntensity = true;
                console.log('‚úÖ HEATMAP RENDERED WITH DATA!');
                console.log('   Max intensity:', maxIntensity.toFixed(2));
                console.log('   Heat points:', nonZeroPoints);
            }
        }
        
        // Get heatmap color based on normalized intensity (0-1)
        function getHeatmapColor(intensity) {
            if (intensity < 0.2) {
                // Low traffic - Deep Blue
                return {
                    center: `rgba(0, 100, 255, ${0.3 + intensity * 0.5})`,
                    mid: `rgba(0, 80, 200, ${0.2 + intensity * 0.3})`,
                    edge: 'rgba(0, 60, 150, 0)'
                };
            } else if (intensity < 0.4) {
                // Light traffic - Cyan/Turquoise
                return {
                    center: `rgba(0, 200, 255, ${0.4 + intensity * 0.4})`,
                    mid: `rgba(0, 180, 230, ${0.3 + intensity * 0.3})`,
                    edge: 'rgba(0, 150, 200, 0)'
                };
            } else if (intensity < 0.6) {
                // Moderate traffic - Green
                return {
                    center: `rgba(50, 255, 100, ${0.5 + intensity * 0.3})`,
                    mid: `rgba(40, 220, 80, ${0.4 + intensity * 0.2})`,
                    edge: 'rgba(30, 180, 60, 0)'
                };
            } else if (intensity < 0.8) {
                // High traffic - Yellow/Orange
                return {
                    center: `rgba(255, 200, 0, ${0.6 + intensity * 0.3})`,
                    mid: `rgba(255, 170, 0, ${0.5 + intensity * 0.2})`,
                    edge: 'rgba(230, 140, 0, 0)'
                };
            } else {
                // Very high traffic - Red/Hot
                return {
                    center: `rgba(255, 50, 50, ${0.7 + intensity * 0.3})`,
                    mid: `rgba(255, 30, 30, ${0.6 + intensity * 0.2})`,
                    edge: 'rgba(220, 20, 20, 0)'
                };
            }
        }

        // Update statistics
        function updateStats() {
            console.log('üìä updateStats() called - visitorCount:', visitorCount);
            
            document.getElementById('currentVisitors').textContent = visitorCount;
            document.getElementById('totalVisitors').textContent = totalVisitorCount;
            
            // Calculate dwell time (simulated for demo)
            const avgDwell = dwellTimes.length > 0 
                ? Math.round(dwellTimes.reduce((a, b) => a + b, 0) / dwellTimes.length)
                : Math.floor(Math.random() * 30 + 20);
            document.getElementById('avgDwellTime').textContent = avgDwell;
            
            // Calculate zone percentages
            let hot = 0, warm = 0, cool = 0, cold = 0;
            
            // Count cells in each category
            heatmapData.forEach(row => {
                row.forEach(cell => {
                    if (cell > 75) hot++;
                    else if (cell > 50) warm++;
                    else if (cell > 25) cool++;
                    else cold++; // Include all areas (including untouched areas)
                });
            });
            
            // Total cells must equal sum of all categories
            const total = hot + warm + cool + cold;
            
            console.log(`Zone counts: hot=${hot}, warm=${warm}, cool=${cool}, cold=${cold}, total=${total}`);
            
            // Calculate percentages
            const hotPct = (hot / total * 100);
            const warmPct = (warm / total * 100);
            const coolPct = (cool / total * 100);
            const coldPct = (cold / total * 100);
            
            console.log(`Zone %: hot=${hotPct.toFixed(2)}%, warm=${warmPct.toFixed(2)}%, cool=${coolPct.toFixed(2)}%, cold=${coldPct.toFixed(2)}%`);
            
            // Round percentages
            let roundedHot = Math.round(hotPct);
            let roundedWarm = Math.round(warmPct);
            let roundedCool = Math.round(coolPct);
            let roundedCold = Math.round(coldPct);
            
            // Fix rounding error - adjust the largest category
            let sum = roundedHot + roundedWarm + roundedCool + roundedCold;
            const diff = 100 - sum;
            
            if (diff !== 0) {
                console.log(`Rounding diff: ${diff}, adjusting largest category`);
                // Find which category has the most cells (not percentage, actual count)
                const maxCount = Math.max(hot, warm, cool, cold);
                if (hot === maxCount) roundedHot += diff;
                else if (warm === maxCount) roundedWarm += diff;
                else if (cool === maxCount) roundedCool += diff;
                else roundedCold += diff;
            }
            
            // Verify sum
            sum = roundedHot + roundedWarm + roundedCool + roundedCold;
            console.log(`Final zone %: hot=${roundedHot}%, warm=${roundedWarm}%, cool=${roundedCool}%, cold=${roundedCold}% (sum=${sum}%)`);
            
            document.getElementById('hotZone').textContent = roundedHot;
            document.getElementById('warmZone').textContent = roundedWarm;
            document.getElementById('coolZone').textContent = roundedCool;
            document.getElementById('coldZone').textContent = roundedCold;
        }

        // Reset heatmap
        function resetHeatmap() {
            heatmapData = heatmapData.map(row => row.map(() => 0));
            totalVisitorCount = 0;
            dwellTimes = [];
            movementPaths = {}; // Clear movement paths
            detectedPeople = []; // Clear current detections
            personFirstSeen = {}; // Clear dwell time tracking
            updateStats();
            addActivityLog('Heatmap and paths reset', 'info');
        }

        // Toggle overlay
        function toggleOverlay() {
            showOverlay = !showOverlay;
            toggleOverlayBtn.innerHTML = showOverlay 
                ? '<i class="fas fa-eye"></i> Hide Overlay'
                : '<i class="fas fa-eye-slash"></i> Show Overlay';
        }
        
        // Toggle heatmap visibility
        function toggleHeatmap() {
            showHeatmap = !showHeatmap;
            heatmapCanvas.style.display = showHeatmap ? 'block' : 'none';
            toggleHeatmapBtn.innerHTML = showHeatmap 
                ? '<i class="fas fa-fire"></i> Hide Heatmap'
                : '<i class="fas fa-fire-slash"></i> Show Heatmap';
            
            console.log('üî• Heatmap visibility:', showHeatmap);
        }

        // Add activity log entry
        function addActivityLog(message, type = 'info') {
            const log = document.getElementById('activityLog');
            const time = new Date().toLocaleTimeString();
            
            const icons = {
                success: 'fa-check-circle',
                error: 'fa-exclamation-circle',
                warning: 'fa-exclamation-triangle',
                info: 'fa-info-circle'
            };
            
            const colors = {
                success: 'var(--success-color)',
                error: 'var(--danger-color)',
                warning: '#f59e0b',
                info: 'var(--primary-color)'
            };
            
            const item = document.createElement('div');
            item.className = 'activity-item';
            item.innerHTML = `
                <i class="fas ${icons[type]}" style="color: ${colors[type]};"></i>
                <span>${message}</span>
                <span class="activity-time" style="margin-left: auto;">${time}</span>
            `;
            
            log.insertBefore(item, log.firstChild);
            
            // Keep only last 10 items
            while (log.children.length > 10) {
                log.removeChild(log.lastChild);
            }
        }

        // Progress bar functions
        function showProgressBar() {
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
                framesAnalyzedCount = 0;
                updateProgress();
                
                // Start progress tracking interval for both camera and video modes
                if (!progressUpdateInterval) {
                    startProgressTracking();
                }
            }
        }

        function hideProgressBar() {
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }
        }

        function updateProgress() {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const videoProgress = document.getElementById('videoProgress');
            const framesAnalyzed = document.getElementById('framesAnalyzed');

            // Update frames analyzed count (works for both camera and video)
            if (framesAnalyzed) {
                framesAnalyzed.textContent = framesAnalyzedCount;
            }

            // For uploaded video: show video progress
            if (isUsingUploadedVideo && videoElement.duration) {
                const currentTime = videoElement.currentTime;
                const duration = videoElement.duration;
                const progress = (currentTime / duration) * 100;

                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }

                if (progressText) {
                    progressText.textContent = Math.round(progress) + '%';
                }

                if (videoProgress) {
                    videoProgress.textContent = formatTime(currentTime) + ' / ' + formatTime(duration);
                }
            } 
            // For camera: show live indicator
            else {
                // Animate progress bar to show activity
                if (progressBar) {
                    // Pulse animation between 30-100%
                    const pulseProgress = 30 + (Math.sin(Date.now() / 500) + 1) * 35;
                    progressBar.style.width = pulseProgress + '%';
                }

                if (progressText) {
                    progressText.textContent = 'LIVE';
                }

                if (videoProgress) {
                    // Show elapsed time for camera
                    const startTime = videoElement._startTime || Date.now();
                    const elapsed = (Date.now() - startTime) / 1000;
                    videoProgress.textContent = 'Live: ' + formatTime(elapsed);
                }
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return mins + ':' + (secs < 10 ? '0' : '') + secs;
        }

        function startProgressTracking() {
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }
            progressUpdateInterval = setInterval(updateProgress, 500); // Update every 500ms
        }

        // Event listeners
        startBtn.addEventListener('click', startCamera);
        stopBtn.addEventListener('click', stopCamera);
        resetHeatmapBtn.addEventListener('click', resetHeatmap);
        toggleOverlayBtn.addEventListener('click', toggleOverlay);
        toggleHeatmapBtn.addEventListener('click', toggleHeatmap);
        videoUploadInput.addEventListener('change', handleVideoUpload);
        playVideoBtn.addEventListener('click', togglePlayPause);
        loadRetailVideoBtn.addEventListener('click', loadRetailVideo);
        testConnectionBtn.addEventListener('click', testConnection);

        // Update slider values display
        heatRadiusInput.addEventListener('input', (e) => {
            document.getElementById('radiusValue').textContent = e.target.value;
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            // Debounce resize events
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvases();
            }, 100);
        });
        
        // Resize canvases and preserve heatmap data
        function resizeCanvases() {
            const videoRect = videoElement.getBoundingClientRect();
            const heatmapContainer = heatmapCanvas.parentElement;
            const heatmapRect = heatmapContainer.getBoundingClientRect();
            
            // Get device pixel ratio for high-DPI displays
            const dpr = window.devicePixelRatio || 1;
            
            // Store old heatmap data dimensions
            const oldGridWidth = heatmapData[0]?.length || 0;
            const oldGridHeight = heatmapData.length || 0;
            const oldHeatmapData = oldGridWidth > 0 ? heatmapData.map(row => [...row]) : null;
            
            console.log('üìê Resizing canvases - preserving', oldGridWidth, 'x', oldGridHeight, 'grid data');
            
            // Set overlay canvas to match video element (with DPI scaling)
            overlayCanvas.width = Math.round(videoRect.width * dpr);
            overlayCanvas.height = Math.round(videoRect.height * dpr);
            overlayCanvas.style.width = videoRect.width + 'px';
            overlayCanvas.style.height = videoRect.height + 'px';
            
            // Scale context for high-DPI
            overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Set heatmap canvas to match its container
            heatmapCanvas.width = Math.round(heatmapRect.width * dpr);
            heatmapCanvas.height = Math.round(heatmapRect.height * dpr);
            heatmapCanvas.style.width = heatmapRect.width + 'px';
            heatmapCanvas.style.height = heatmapRect.height + 'px';
            
            // Scale context for high-DPI
            heatmapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Calculate new grid dimensions
            const newGridWidth = Math.ceil(heatmapRect.width / 10);
            const newGridHeight = Math.ceil(heatmapRect.height / 10);
            
            // Create new heatmap data grid
            heatmapData = Array(newGridHeight).fill(0).map(() => Array(newGridWidth).fill(0));
            
            // Scale and preserve old heatmap data if it exists
            if (oldHeatmapData && oldGridWidth > 0 && oldGridHeight > 0) {
                const scaleX = newGridWidth / oldGridWidth;
                const scaleY = newGridHeight / oldGridHeight;
                
                console.log('üìä Scaling heatmap data:', oldGridWidth, 'x', oldGridHeight, '->', newGridWidth, 'x', newGridHeight);
                
                let preservedPoints = 0;
                for (let oldY = 0; oldY < oldGridHeight; oldY++) {
                    for (let oldX = 0; oldX < oldGridWidth; oldX++) {
                        const intensity = oldHeatmapData[oldY][oldX];
                        if (intensity > 0) {
                            const newX = Math.floor(oldX * scaleX);
                            const newY = Math.floor(oldY * scaleY);
                            if (newX < newGridWidth && newY < newGridHeight) {
                                heatmapData[newY][newX] = Math.max(heatmapData[newY][newX], intensity);
                                preservedPoints++;
                            }
                        }
                    }
                }
                
                console.log('‚úÖ Preserved', preservedPoints, 'heatmap points, re-rendering...');
                
                // Force re-render the heatmap with scaled data
                // Use requestAnimationFrame to ensure the canvas is ready
                requestAnimationFrame(() => {
                    renderHeatmap();
                    console.log('‚úÖ Heatmap re-rendered after resize');
                });
            } else {
                console.log('‚ÑπÔ∏è No heatmap data to preserve during resize');
            }
            
            // Also reset offscreen canvas so it gets recreated with correct dimensions
            offscreenCanvas = null;
            offscreenCtx = null;
            
            console.log('üìê Canvases resized:', newGridWidth, 'x', newGridHeight, 'grid');
        }

        // Create demo heatmap pattern on page load
        function showDemoHeatmap() {
            console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
            console.log('‚ïë  üé® LOADING DEMO HEATMAP PATTERN  ‚ïë');
            console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
            
            // Ensure canvases are initialized first
            if (heatmapData.length === 0 || !heatmapData[0]) {
                console.log('üìê Initializing canvases for demo...');
                initCanvases();
            }
            
            // Clear existing data
            heatmapData = heatmapData.map(row => row.map(() => 0));
            
            // Create interesting demo pattern showing different intensity zones
            const width = heatmapData[0].length;
            const height = heatmapData.length;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Pattern 1: Entrance area (bottom center) - high traffic
            addDemoHeatPoint(centerX, height - 8, 120);
            addDemoHeatPoint(centerX - 5, height - 10, 90);
            addDemoHeatPoint(centerX + 5, height - 10, 90);
            
            // Pattern 2: Popular product zones (scattered hotspots)
            addDemoHeatPoint(centerX - 15, centerY - 10, 150); // Hot product zone
            addDemoHeatPoint(centerX + 18, centerY - 8, 140);  // Another hot zone
            addDemoHeatPoint(centerX - 20, centerY + 5, 110);  // Moderate zone
            
            // Pattern 3: Browse areas (medium traffic)
            addDemoHeatPoint(centerX + 10, centerY + 10, 80);
            addDemoHeatPoint(centerX - 8, centerY + 15, 75);
            addDemoHeatPoint(centerX + 20, height - 15, 85);
            
            // Pattern 4: Checkout/counter area (top area)
            addDemoHeatPoint(centerX - 10, 8, 95);
            addDemoHeatPoint(centerX + 8, 10, 95);
            
            // Pattern 5: Aisle traffic (light traffic)
            addDemoHeatPoint(centerX, centerY, 60);
            addDemoHeatPoint(centerX - 25, centerY - 5, 50);
            addDemoHeatPoint(centerX + 25, centerY + 5, 55);
            
            // Render the demo heatmap
            renderHeatmap();
            
            // Update stats to show demo data
            updateStats();
            
            // Add a note in the activity log
            addActivityLog('üìä Demo heatmap loaded - shows sample traffic pattern', 'info');
            
            // Add note to VLM response box
            const vlmResponseBox = document.getElementById('vlmResponse');
            if (vlmResponseBox) {
                vlmResponseBox.innerHTML = `
                    <div style="text-align: left !important; display: block; width: 100%;">
                        <div style="color: var(--accent-color); font-weight: 600; margin-bottom: 8px;">
                            <i class="fas fa-paint-brush"></i> Demo Heatmap Pattern
                        </div>
                        <span style="color: var(--text-secondary); font-size: 0.9em;">
                            This smooth gradient heatmap shows sample retail traffic patterns:
                            <br>‚Ä¢ <span style="color: #FF5555;">Red zones</span> = High traffic hotspots
                            <br>‚Ä¢ <span style="color: #FFFF00;">Yellow zones</span> = Popular areas  
                            <br>‚Ä¢ <span style="color: #00FF88;">Green zones</span> = Moderate activity
                            <br>‚Ä¢ <span style="color: #4499FF;">Blue zones</span> = Light traffic
                            <br><br>Start camera or upload video to analyze real traffic.
                        </span>
                    </div>
                `;
            }
            
            console.log('‚úÖ Demo heatmap pattern loaded');
        }
        
        // Helper function to add a demo heat point
        function addDemoHeatPoint(gridX, gridY, intensity) {
            const radius = 5; // Standard radius
            
            gridX = Math.round(gridX);
            gridY = Math.round(gridY);
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= radius) {
                        const gx = gridX + dx;
                        const gy = gridY + dy;
                        
                        if (gy >= 0 && gy < heatmapData.length && gx >= 0 && gx < heatmapData[0].length) {
                            const falloff = 1 - (distance / radius);
                            heatmapData[gy][gx] = Math.min(255, heatmapData[gy][gx] + intensity * falloff);
                        }
                    }
                }
            }
        }
        
        // Clear demo heatmap when starting actual analysis
        function clearDemoHeatmap() {
            // This will be called automatically when starting camera/video
            heatmapData = heatmapData.map(row => row.map(() => 0));
            console.log('üßπ Demo heatmap cleared for live analysis');
        }

        // Initialize
        console.log('Smart Retail Analytics - Heatmap Demo Ready');
        console.log('üí° Loading demo heatmap pattern...');
        
        // Wait for DOM to be fully loaded, then show demo heatmap
        setTimeout(() => {
            showDemoHeatmap();
        }, 100);
    </script>
</body>
</html>


